---
title: "Illustrative Examples of Imaginary Structures"
output:
  html_document: default
  pdf_document: default
---
This doc shows some illustrative examples of imaginary structures in CSS data.

## Glossary
- __P-EO__: Partially false errors of omission
- __P-EC__: Partially false errors of commission
- __C-EO__: Completely false errors of omission
- __C-EC__: Completely false errors of commission
- __M-E__: Mixed false errors

## Installation
To calculate imaginary structure statistics, you can install the `imaginarycss` package from [CRAN](https://CRAN.R-project.org).

```r
# install.packages("imaginarycss")
```
Or you can also install the development version from [GitHub](https://github.com/).
``` r
# install.packages("devtools")
# devtools::install_github("gvegayon/imaginary-structures/imaginarycss@main")
```

## 3-node Graph Case with 2-node Imaginary Motifs
First, we define a true graph. In this case, the true graph includes 3 nodes and 3 edges. It also has all the possible dyadic MAN conditions:

- mutual
- asymmetric
- null

Consequently, this true graph example can cover all the possible dyadic imaginary motifs, compared to different perceived graph patterns.

In the following, we're also going to construct three perceived graphs that compare with the true graph. we calculate example imaginary motif statistics using these examples.

```{r message = FALSE, warning = FALSE}
library(sna)
library(imaginarycss)
library(ergmito)
```

```{r true graph}
# library(imaginarycss)
# 3 actor true graph
t_source_ <- c("A","A","B") 
t_target_ <- c("B","C","A")
t_source <- c(1,1,2)
t_target <- c(2,3,1)
t_ <- as.network(data.frame(from = t_source_,
                      to = t_target_))

set.seed(1231)
coords <- gplot(
  t_, displaylabels = T, usecurve = T, edge.curve = .1,
  main = "True", jitter = FALSE
  )
```

### A's perceived graph
We define A's perceived graph and then compare it with the true graph. By doing so, we should obverse the following imaginary 2-node motifs:

- P-EO = 1
- P-EC = 1
- C-EO = 0
- C-EC = 0


```{r A graph}
# A's perceived graph
a_source_ <- c("A","A","C")
a_target_ <- c("B","C","A")
a_source <- c(1,1,3)
a_target <- c(2,3,1)
a_ <- as.network(data.frame(from = a_source_,
                 to = a_target_))
gplot(
  a_, displaylabels = T, usecurve = T, edge.curve = .1,
  coord = coords, main = "A", jitter = FALSE
  )
```

### B's perceived graph
Compared to the true graph, B should provide the following imaginary 2-node motifs:

- P-EO = 0
- P-EC = 0
- C-EO = 2
- C-EC = 3

```{r B graph}
# C's perceived graph
b_source_ <- c("C","B","C")
b_target_ <- c("A","C","B")
b_source <- c(3,2,3) -1
b_target <- c(1,3,2) -1
b_ <- as.network(data.frame(from = b_source_,
                            to = b_target_),matrix.type='edgelist')
gplot(
  b_, displaylabels = T, usecurve = T, edge.curve = .1,
  coord = coords, main = "B", jitter = FALSE
  )
```

### C's perceived graph
This should be C's perceived graph statistics:

- P-EO = 2
- P-EC = 1
- C-EO = 0
- C-EC = 0

```{r C graph}
# C's perceived graph
c_source_ <- c("C","B")
c_target_ <- c("A","A")
c_source <- c(3,2) -1
c_target <- c(1,1) -1
c_ <- as.network(data.frame(from = c_source_,
                      to = c_target_),matrix.type='edgelist')
gplot(
  c_, displaylabels = T, usecurve = T, edge.curve = .1,
  coord = coords, main = "C", jitter = FALSE
  )
```

### Count Imaginary Errors

```{r all-three, echo = FALSE}
op <- par(mfcol=c(2, 2), mar = rep(1, 4))
gplot(
  t_, displaylabels = T, usecurve = T, edge.curve = .1,
  coord = coords, main = "True", jitter = FALSE
  )
gplot(
  a_, displaylabels = T, usecurve = T, edge.curve = .1,
  coord = coords, main = "A", jitter = FALSE)

gplot(
  b_, displaylabels = T, usecurve = T, edge.curve = .1,
  coord = coords, main = "B", jitter = FALSE)

gplot(
  c_, displaylabels = T, usecurve = T, edge.curve = .1,
  coord = coords, main = "C", jitter = FALSE)
par(op)
```


Let's count errors using `count_recip_errors` in the imaginary_css package.

```{r Errors}
big_graph <- blockdiagonalize(list(t_, a_, b_, c_)) #
graph <- new_barry_graph(as.matrix(big_graph), n = 3)

ans <- count_recip_errors(graph)
ans$name <- gsub("[(][0-9]+[)]", "", ans$name)
ans
```

<!-- > ans -->
<!--   id                                name value -->
<!-- 1  0   Partially false recip (omission)      1 -->
<!-- 2  1   Partially false recip (omission)      0 -->
<!-- 3  0  Partially false recip (comission)      1 -->
<!-- 4  1  Partially false recip (comission)      0 -->
<!-- 5  0  Completely false recip (omission)      0 -->
<!-- 6  1  Completely false recip (omission)      1 -->
<!-- 7  0 Completely false recip (comission)      0 -->
<!-- 8  1 Completely false recip (comission)      1 -->


# Rewiring

```{r}
library(netdiffuseR)
load("../data/krackhardt_css.RData")

nets <- c(list(friend_net), friendship_nets)

# Preparing data
graph <- lapply(nets, as.matrix)
graph <- lapply(graph, methods::as, "dgCMatrix")
graph[[1]] <- as.matrix(graph[[1]])

ans <- replicate(n = 100, {
  
  graph0 <- graph
  
  graph0[2:length(graph)] <- lapply(graph[2:length(graph)], function(g) {
    as.matrix(rewire_graph(g, p = 20, algorithm = "swap"))
    })
  
  graph0 <- blockdiagonalize(graph0)
  
  graph0 <- new_barry_graph(as.matrix(graph0), n = length(friendship_nets))

  out <- count_recip_errors(graph0)
  out$name <- gsub("[(][0-9]+[)]", "", out$name)
  out
}, simplify = FALSE)

ans <- do.call(rbind, ans)



```

## Krackhardt's CSS data

We have access to a CSS data set that Krackhardt (1987) collected.

```{r Krackhardt CSS}
krack_css <- load('../data/krackhardt_css.RData')

# the case of friendship
true <- as.network(consensus(friendship_nets,mode="digraph",diag=FALSE,method="OR.row"))
# true <- as.network(apply(fr.post.actor$net, c(2, 3), median)) #bbnam as true
big_krack <- blockdiagonalize(c(list(true),friendship_nets))
# the case of advice
true <- as.network(consensus(advice_nets,mode="digraph",diag=FALSE,method="OR.row"))
big_krack <- blockdiagonalize(c(list(true),advice_nets))

# create a barry graph object
krack_graph <- new_barry_graph(as.matrix(big_krack), n = 21)
ans <- count_recip_errors(krack_graph)
ans$name <- gsub("[(][0-9]+[)]", "", ans$name)
ans
```

Using ans, we visualize histograms to check the distributions of each error case. Here, we use ggplot2.

```{r}
library(ggplot2)

ggplot(data = ans,
        aes(x = value))+
  geom_histogram()+
  facet_grid(name~.)+
  theme_classic(base_size = 18) +
  theme(axis.title = element_text(face = "bold"),legend.position = 'none')
```

BNAM (Baysian network inference): Let's start by defining some priors for the Bayesian network inference model. We'll use an uninformative network prior, together with weakly informative (but diffuse and symmetric) priors on the error rates. Read the man page ("?bbnam") to get more information about how the routine works.

Check Lee & Butts (2018; 2020) to get their parameters.
```{r}
np<-matrix(0.5,21,21)  # 21 x 21 matrix of Bernoulli parameters (since n=21)
emp<-sapply(c(1,11),rep,21)  # Beta(3,11) priors for false negatives
epp<-sapply(c(1,11),rep,21)  # Beta(3,11) priors for false positives
hist(rbeta(100000,3,11))  # This gives you a sense of what the priors look like!

# Now, let's take some posterior draws for the friendship network, using 
# various models (warning: slow)
# fr.post.fixed<-bbnam.fixed(friendship_nets,nprior=np,em=3/(3+11),ep=3/(3+11))
# fr.post.pooled<-bbnam.pooled(friendship_nets,nprior=np,em=emp[1,],ep=epp[1,])
fr.post.actor<-bbnam.actor(friendship_nets,nprior=np,em=emp,ep=epp)
summary(fr.post.actor)
plot(fr.post.actor)
gplot(as.network(apply(fr.post.actor$net, c(2, 3), median)))
```
